package io.mockative

import io.mockative.matchers.ArgumentsMatcher
import io.mockative.matchers.Matcher
import io.mockative.matchers.SpecificArgumentsMatcher
import kotlin.reflect.KFunction

fun <#type-param-list#, R, F> whenSuspending(instance: Any, function: F): WhenSuspending#count#Builder<#type-param-list#, R> where F : suspend (#type-param-list#) -> R, F : KFunction<R> {
    return whenSuspending#count#(instance, function)
}

fun <#type-param-list#, R, F> whenSuspending#count#(instance: Any, function: F): WhenSuspending#count#Builder<#type-param-list#, R> where F : suspend (#type-param-list#) -> R, F : KFunction<R> {
    return WhenSuspending#count#Builder(instance.asMockable(), function)
}

class WhenSuspending#count#Builder<#type-param-list#, R>(private val mock: Mockable, private val function: KFunction<R>) {
    fun with(#with.parameters#): ResultBuilder {
        val arguments = SpecificArgumentsMatcher(listOf(#with.arguments#))
        return ResultBuilder(arguments)
    }

    inner class ResultBuilder(private val arguments: ArgumentsMatcher) :
        AnySuspendResultBuilder<R> {
        fun then(block: suspend (#type-param-list#) -> R) {
            val expectation = Expectation.Function(function.name, arguments)
            val stub = SuspendStub(expectation) { args ->
                block(#then.arguments#)
            }
            mock.addSuspendStub(stub)
        }

        override fun thenInvoke(block: suspend () -> R) = then { #thenInvoke.underscores# -> block() }
    }
}